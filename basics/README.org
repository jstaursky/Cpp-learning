#+TITLE:C++ Basics
* Lvalues and Rvalues
#+begin_quote
An lvalue is an expression that refers to a memory location and allows us to take the address of that memory location via the & operator.
#+end_quote

#+begin_quote
An rvalue is an expression that is not an lvalue.
#+end_quote
Some examples
#+begin_src C++
  // lvalues:
  //
  int i = 42;
  i = 43;           // ok, i is an lvalue
  int* p = &i;      // ok, i is an lvalue
  int& foo();
  foo() = 42;       // ok, foo() is an lvalue
  int* p1 = &foo(); // ok, foo() is an lvalue

  // rvalues:
  //
  int foobar();
  int j = 0;
  j = foobar();        // ok, foobar() is an rvalue
  int* p2 = &foobar(); // error, cannot take the address of an rvalue
  j = 42;              // ok, 42 is an rvalue
#+end_src
[[http://thbecker.net/articles/rvalue_references/section_01.htmlexternal_link][ reference]]

* TODO Pointer types
Pointers are declarations of the form.
#+begin_src C++
  int *foo = &bar;
#+end_src
This assigns =foo= to the address of the variable =bar=;
- To access the value of =bar=, you must make statements of the form =*foo=.
=*= is the _indirection_ or _dereference_ operator which enables you to access the object the pointer points to. This becomes important in situations where you want a function to modify its arguments and use call by reference (albeit references provide cleaner method of accomplishing this).
e.g.,
#+begin_src C++
  void swap(int* x, int* y)
  {
    int tmp;
    tmp = *x;
    *x = *y;                      // accesses a & b through indirection.
    *y = tmp;
  }
  // code
  swap(&a, &b);
#+end_src

** Complicated pointer declarations with const
Using =const= with pointers can enable certain types of protections depending on your needs.
*** Pointers to a constant int
#+begin_src C++
  int const* foo;            // pointer to const int
#+end_src
Provides the following type of protection.
#+begin_quote
Protects the integer being pointed to from being changed/modified.
- The value of =foo= can change.
- The value of =*foo= cannot change.
#+end_quote
Note:
- the integer being pointed to does not have to be declared =const=.
- the pointer to a constant int can change where it points, but cannot change the value of the variable to which it points.
e.g.,
#+begin_src C++
  int fu = 0;
  int const* foo = &fu;           // foo is a pointer to a const int.

  int const bar = 1;
  foo = &bar;                     // foo can be changed to ref
                                  // another int of constant int.
#+end_src

*TL;DR* =int const* foo= protects the values of the variable to which it points. Preventing assignments such as =*foo = 100=. \\
Such assignments will result in the compiler error:
#+begin_src text
you cannot assign tp a variable that is const.
#+end_src

*** Constant pointers
#+begin_src C++
  int* const foo;            // const pointer to int
#+end_src
Provides the following type of protection.
#+begin_quote
The pointer cannot be changed to point to somewhere else.
- The value of =*foo= can change.
- The value of =foo= cannot change.
#+end_quote
Note:
- =foo= can change the value of the variable it is initialized to.
- once initialized to a variable, =foo= cannot change to point elsewhere.

**** Caveats to using constant pointers
=int* const foo= must be initialized to a nonconstant variable.
For some reason, intializing a constant pointer to int to a constant int can enable the const int to be changed through the constant pointer to int.
i.e.,
#+begin_src C++
  int const foo = 1;
  int* const bar = &foo;
#+end_src
Results in the compiler warning
#+begin_src text
initialization discards qualifiers from pointer target type.
#+end_src

*** Constant pointers to constants
#+begin_src C++
  int const* const foo = &bar;    // const pointer to const int
#+end_src
Provides the following type of protection.
#+begin_quote
The pointer cannot point to another variable once initialized, and the value of the variable being pointed to cannot be changed.
#+end_quote
Note:
- A constant pointer to a constant must be initialized when declared.

** Smart Pointers
- Useful for dynamic memory applications.
- Acts like a regular pointer, with the important exception that it automatically deletes the object to which it points.
*** shared_ptr
Allows multiple pointers to refer to the same object.
- Is a template.
#+begin_src C++
  shared_ptr<string> p1;          // shared_ptr that can point to a string
  shared_ptr<list<int>> p2;       // p2 can point at a list of ints.
#+end_src

- Has an associated counter which tracks the number of shared_ptrs refering to the same object.
  NOTE: the reference count is incremented when:
  - we copy a =shared_ptr=.
    e.g.,
    #+begin_src C++
      shared_ptr<T> p = q;    // when initializing another shared_ptr.
      r = q;  // when used as the right-hand operand of an assignment.
    #+end_src
  - Also when we pass it to or return from a function by value.
  NOTE: the reference count is decremented when:
  - we assign a new value to the =shared_ptr=.
  - when the =shared_ptr= itself is destroyed, like when a local =shared_ptr= goes out of scope.

#+begin_quote
Once a =shared_ptr= counter goes to zero, the =shared_ptr= automatically frees the object that it manages.
#+end_quote

#+begin_src C++
  auto r = make_shared<int>(42);  // int to which r points has one ref.
  r = q;         // assign to r, making it point to a different address
                 // Effects:
                 // (1) Increases the use count for the object to which q
                 //     points.
                 // (2) Reduces the use count of the object to which r
                 //     had pointed to.
                 // (3) The object r had pointed to has no users;
                 //     that object is automatically freed.
#+end_src

#+begin_quote
=shared_ptr= ensures that so long as there are any shared_ptrs attached to the memory, the memory itself will not be freed.
#+end_quote

**** operations common to shared_ptr and unique_ptr
1) =shared_ptr<T> sp= 
   =unique_ptr<T> up= 
   Null smart pointer that can point to objects of type =T=.
2) =p=
   Use p as a condition; =true= if p points to an object.
3) =*p= 
   Dereference p to get the object to which p points.
4) =p->member=
   Synonym for (*p).member
5) =p.get()=
   Returns the pointer in p. Use with caution; the object to which the returned pointer points will disappear when the smart pointer deletes it.
6) =swap(p,q)= (alt. =p.swap(q)=)
   Swaps the pointers in p and q.


**** Operations Specific to shared_ptr
1) =make_shared<T>(args)= 
   Returns a shared_ptr pointing to a dynamically allocated object of type T. Uses ~args~ to initialize that object.
2) =shared_ptr<T>p(q)= 
   p is a copy of the shared_prt q; increments the count in q. The pointer in q must be convertable to ~T*~.
3) =p = q= 
   p and q are shared_ptr's holding pointers that can be converted to one another. Decrements p's reference count and increments q's count; delets p's existing memory if p's count goes to 0.
4) =p.unique()=
   Returns =true= if =p.use_count()= is one; =false= otherwise.
5) =p.use_count()=   
   Returns the number of objects sharing with p; may be a slow operation, intended primarily for debugging purposes.


*** unique_ptr
"owns" the object to which it points.

* Reference types
Like a pointer, a reference is an alias for an object (or variable), is usually implemented to hold a machine address of an object (or variable), and does not impose performance overhead compared to pointers.

Ordinarily, when we initialize a variable, the value of the initializer is copied into the object we are creating. When we define a reference, instead of copying the initializer’s value, we *bind* the reference to its initializer. Once initialized, a reference remains bound to its initial object.

- The notation X& means “reference to X”.
#+begin_src C++
int val = 1;
int &refval = val;
#+end_src
Note:
- A reference variable must be initialized.
- A reference variable must be initialized to an object of the same type as the reference type (e.g., =int= in example above).

** Differences between reference and pointer.
1) A reference can be accessed with exactly the same
   syntax as the name of an object.
2) A reference always refers to the object to which it
   was initialized.
3) There is no “null reference”, and we may assume
   that a reference refers to an object. 
   
** Benefits to using references 
C++ passes parameters to functions _by value_, which simply means that the called function is given _the values_ of its arguements rather than the arguments themselves--the arguments themselves are left alone and unmodified. This can induce a non-negligable overhead if the value of a variable being passed is very large; so it becomes desirable to instead pass a reference to the argument and act upon the argument itself.

Example: Passing by reference
#+begin_src C++
  void function(int& foo);     // function prototype.
  // ...
  int bar = 1;
  function(bar);                  // bar returns modified according to 
                                  // the implementation of function.
#+end_src
 Passing by reference removes the overhead associated with passing by value and results in an increased efficiency with the function call.
 
*** Passing by reference caveat
However, passing by reference also opens the possibility of the argument being passed to be modified. This potientially undesirable behavior can be negated if we add to the functions parameter declaration the =const= qualifier.
#+begin_src C++
  void function(int const& foo);
  // ...
  int bar = 1;
  function(bar);
#+end_src
Now =bar= upon return will stay unmodifed yet we have retained the increase in efficiency associated with passing by reference.

**** Aside on declarations
The following two declarations are equivalent.
#+begin_src C++
  // following two declarations are equivalent.
  const int& foo;                 // foo is reference to const int
  int const& foo;                 // foo is reference to const int
#+end_src
It is preferable to follow the convention of placing =const= after whatever type you want to remain constant. This convention enables you to always know the answer to the question "what is constant?" it is always what is in front of the =const= qualifier.

** Reference return type
Calls to functions that return references are lvalues; other return types are rvalues. This means we can assign to the result of a function that returns a reference to a non-constant.
#+begin_src C++
  char &getString(string &str, string::size_type idx)
  {
    return str[idx];
  }
  int main()
  {
      string var;
      // code...
      getString(var, 0) = 'A';       // changes var[0] to A.
      // code...
  }
#+end_src

Note:
- *Never Return a Reference or Pointer to a Local Object*

* Type conversions - explicit conversions -- Casting
C++ has different casting styles in addition to the traditional c-style cast.
** C-style cast
#+begin_src text
  (type) expression;
#+end_src
example
#+begin_src C++
  char *foo = (char*) bar;
#+end_src
c-style casts cover all the cases that named casts do but named casts aid the reader what the intent behind that cast was.

** Named Casts
#+begin_src text
  cast-name<type>(expression);
#+end_src
where
- ~type~ is the target type of the conversion.
- ~expression~ is the value to be cast.
- ~cast-name~ may be one of
  - ~static_cast~
  - ~dynamic_cast~
  - ~const_cast~
  - ~reinterpret_cast~
~cast-name~ determines what kind of conversion is performed.
*** static_casting
~static_cast~ can convert:
1) Pointers to classes of related type.
   - Compiler error if classes are not related -- see example below w/ ~static_cast<A*>(&b);~.
   - Dangerous to cast down a class hierarchy -- see example below w/ ~static_cast<C*>(&b);~.
2) Non-pointer conversion
   • e.g. float to int.
static_cast is checked at compile time.

example static cast
#+begin_src C++
  class A {
  public:
      int x;
  };
  class B {
  public:
      float x;
  };
  class C : public B {
  public:
      char x;
  };
#+end_src

#+begin_src C++
  void foo() {
      B b; C c;

      A* aptr = static_cast<A*>(&b); // compiler error
      B* bptr = static_cast<B*>(&c); // OK
      C* cptr = static_cast<C*>(&b); // compiles, but dangerous
  }                                  // class B type being cast down to C.
#+end_src

*** dynamic_casting
~dynamic_cast~ can convert:
1) Pointers to classes of related type
2) References to classes of related type.
~dynamic_cast~ is checked at both *compile time* and *run time*
- Casts between unrelated classes fail at compile time.
- Casts from base to derived fail at run time if the pointed-to-object is not the derived type.

example dynamic cast
#+begin_src C++
  class Base {
    public:
      virtual void foo() { }
      float x;
  };

  class Derived : public Base {
    public:
      char x;
  };
#+end_src

#+begin_src C++
  void foo() {
    Base b; 
    Derived d;
    // OK (run-time check passes)
    Base* bptr = dynamic_cast<Base*>(&d);
    assert(bptr != nullptr);
  
    // OK (run-time check passes)
    Derived* dptr = dynamic_cast<Derived*>(bptr);
    assert(dptr != nullptr);

    // Run-time check fails, returns nullptr
    bptr = &b;
    dptr = dynamic_cast<Derived*>(bptr);
    assert(dptr != nullptr);
  }
#+end_src

** const_casting
~const_cast~ adds or strips const-ness
- Dangerous
#+begin_src C++
  void foo(int* x) {
    *x++;
  }

  void bar(const int* x) {
    foo(x);                       // compiler error

    foo(const_cast<int*>(x));     // succeeds
  }

  int main(int argc, char** argv) {
    int x = 7;
    bar(&x);
    return 0;
  }
#+end_src

** reinterpret_cast
~reinterpret_cast~ casts between incompatible types
- Low-level reinterpretation of the bit pattern
- e.g., storing a pointer in an ~int~, or vice-versa
  - works as long as the integral type is "wide" enough
- converting between incompatible pointers
  - Dangerous

* Functions
** Function Overloading
Function overloading is having multiple functions declared in the same scope with the same name, differing only in the arguments they accept (a.k.a. the functions _signature_).

#+begin_quote
The Compiler infers which of the functions to call from the parameters you provide it.
#+end_quote

Example,
#+begin_src C++
  void print(std::string const &str)
  {
    std::cout << "This is a string: " << str << std::endl;
  }

  void print(int num)
  {
    std::cout << "This is an int: " << num << std::endl;
  }

  // Can call print w/out worrying about whether the arg is a string or int.
  print("Hello World");
  print(1932);
#+end_src
But be careful! Following circumstances can be tricky:
- =void print(int num)= and =void print(double num)= are defined. Then when calling =print(5)= it is not immediatley clear which overload of print is called.
- overloads that accept optional parameters.
  Example,
  #+begin_src C++
    void print(int num1, int num2 = 0)
    //num2 defaults to 0 if not included
    {
        std::cout << "These are ints: << num1 << " and \
            " << num2 << std::endl";
    }
    void print(int num)
    {
        std::cout << "This is an int: " << num << std::endl;
    }
  #+end_src
  A for a call such as =print(17)= the compiler will be unable to tell whether to use the first or second function definition b/c the optional parameter.

** Optional parameters
Example,
#+begin_src C++
  void countdown(int n = 3)
  {
    while (n >= 0)
      std::cout << n-- << '\n';
  }
#+end_src
A call such as =countdown()= will print
#+begin_src text
  3
  2
  1
#+end_src
